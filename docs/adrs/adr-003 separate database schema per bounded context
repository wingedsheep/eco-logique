# ADR-003: Separate Database Schemas per Bounded Context

**Status**: Accepted

**Date**: 2024-11-02

---

## Decision

Each module owns its data exclusively through **separate PostgreSQL schemas**. No shared tables, no foreign keys across schemas.

---

## Schema Setup

One schema per module:

```sql
-- docker/init/init-databases.sql
CREATE SCHEMA payment;
CREATE SCHEMA products;
CREATE SCHEMA shipping;
CREATE SCHEMA inventory;
CREATE SCHEMA users;

GRANT ALL ON SCHEMA payment TO economique_app;
GRANT ALL ON SCHEMA products TO economique_app;
GRANT ALL ON SCHEMA shipping TO economique_app;
GRANT ALL ON SCHEMA inventory TO economique_app;
GRANT ALL ON SCHEMA users TO economique_app;
```

---

## Migration Structure

Flyway migrations organized by module:

```
application/src/main/resources/db/migration/
├── payment/
│   ├── V1__create_payment_tables.sql
│   └── V2__add_settlement_table.sql
├── products/
│   ├── V1__create_products_table.sql
│   └── V2__add_sustainability_columns.sql
├── shipping/
│   └── V1__create_shipment_tables.sql
├── inventory/
│   └── V1__create_inventory_tables.sql
└── users/
    └── V1__create_users_table.sql
```

**Flyway configuration**:
```yaml
# application.yml
spring:
  flyway:
    locations:
      - classpath:db/migration/payment
      - classpath:db/migration/products
      - classpath:db/migration/shipping
      - classpath:db/migration/inventory
      - classpath:db/migration/users
```

---

## Table Creation

Always specify schema in migrations:

```sql
-- products/V1__create_products_table.sql
CREATE TABLE products.products (
    id VARCHAR(255) PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    category_code VARCHAR(50) NOT NULL,
    price_amount DECIMAL(19, 2) NOT NULL,
    price_currency VARCHAR(3) NOT NULL,
    weight_grams INTEGER NOT NULL,
    sustainability_rating VARCHAR(10) NOT NULL,
    carbon_footprint_kg DECIMAL(10, 2) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_products_category ON products.products(category_code);
```

```sql
-- inventory/V1__create_inventory_tables.sql
CREATE TABLE inventory.warehouses (
    id VARCHAR(255) PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    country_code VARCHAR(2) NOT NULL
);

CREATE TABLE inventory.inventory_items (
    id VARCHAR(255) PRIMARY KEY,
    product_id VARCHAR(255) NOT NULL,  -- Reference to products schema
    warehouse_id VARCHAR(255) NOT NULL,
    quantity INTEGER NOT NULL,
    FOREIGN KEY (warehouse_id) REFERENCES inventory.warehouses(id)
    -- NO foreign key to products.products
);

CREATE INDEX idx_inventory_product ON inventory.inventory_items(product_id);
```

---

## Entity Configuration

Specify schema in entity annotations:

```kotlin
// products-impl
@Table("products", schema = "products")
internal data class ProductEntity(
    @Id val id: String,
    val name: String,
    val categoryCode: String,
    val priceAmount: BigDecimal,
    val priceCurrency: String
)

// inventory-impl
@Table("inventory_items", schema = "inventory")
internal data class InventoryItemEntity(
    @Id val id: String,
    val productId: String,  // String reference, not entity relation
    val warehouseId: String,
    val quantity: Int
)
```

---

## Cross-Schema References

**Never use foreign keys** across schemas. Reference by ID only.

```sql
-- ✗ Bad - Foreign key across schemas
CREATE TABLE inventory.inventory_items (
    product_id VARCHAR(255) NOT NULL,
    FOREIGN KEY (product_id) REFERENCES products.products(id)  -- Don't do this
);

-- ✓ Good - String reference only
CREATE TABLE inventory.inventory_items (
    product_id VARCHAR(255) NOT NULL
    -- No foreign key
);
```

**Access cross-schema data** through service APIs:

```kotlin
@Service
class InventoryServiceImpl(
    private val inventoryRepository: InventoryRepository,
    private val productService: ProductService  // From products-api
) : InventoryService {

    override fun reserveStock(productId: ProductId, quantity: Quantity): Result<Unit> {
        // Validate product exists via API, not database join
        productService.getProduct(productId).getOrElse {
            return Result.failure(it)
        }

        val item = inventoryRepository.findByProductId(productId)
            ?: return Result.failure(NoSuchElementException("No inventory for product"))

        // Process reservation
    }
}
```

---

## Querying Across Schemas

### Option 1: Service Layer Composition (Preferred)
Combine data in application code:

```kotlin
@Service
class ShippingServiceImpl(
    private val shipmentRepository: ShipmentRepository,
    private val productService: ProductService,
    private val inventoryService: InventoryService
) : ShippingService {

    override fun createShipment(productId: ProductId): Result<Shipment> {
        // Get data from different schemas via services
        val product = productService.getProduct(productId).getOrElse {
            return Result.failure(it)
        }

        val warehouse = inventoryService.findWarehouseForProduct(productId).getOrElse {
            return Result.failure(it)
        }

        // Combine in application
        return Result.success(
            Shipment(
                id = ShipmentId.generate(),
                productId = productId,
                weight = product.weight,
                originWarehouse = warehouse.id
            )
        )
    }
}
```

### Option 2: Read-Only Views (If Needed)
Create materialized views for complex reporting:

```sql
-- reporting schema (separate from domain schemas)
CREATE SCHEMA reporting;

CREATE MATERIALIZED VIEW reporting.product_inventory AS
SELECT
    p.id as product_id,
    p.name as product_name,
    i.warehouse_id,
    i.quantity
FROM products.products p
JOIN inventory.inventory_items i ON p.id = i.product_id;

-- Refresh periodically
REFRESH MATERIALIZED VIEW reporting.product_inventory;
```

---

## Schema Ownership

**Rules**:
1. Only the owning module can modify its schema
2. Other modules read through service APIs
3. No cross-schema joins in application code
4. No shared tables or "common" schema

```
✓ products-impl modifies products schema
✗ shipping-impl modifies products schema
✗ products-impl reads from inventory schema directly
✓ products-impl calls InventoryService API
```

---

## Testing

Use separate schemas in tests too:

```kotlin
@SpringBootTest
@Testcontainers
class ProductRepositoryIntegrationTest {

    @Container
    private val postgres = PostgreSQLContainer<Nothing>("postgres:15")
        .withInitScript("init-schemas.sql")

    @Autowired
    private lateinit var productRepository: ProductRepository

    @Test
    fun `save should persist product in products schema`() {
        val product = buildProduct()

        val saved = productRepository.save(product)

        assertThat(saved.id).isNotNull()
    }
}
```

---

## Consequences

### Positive
- Clear data ownership
- Modules can evolve independently
- Easy to extract to separate databases later
- Forces proper API boundaries
- No accidental coupling through database

### Negative
- Cannot use foreign keys for referential integrity across modules
- Cannot use database joins across modules
- More complex reporting queries
- Potential data consistency challenges (eventual consistency)

---

## Migration Strategy

If extracting module to microservice later:

1. Module already has separate schema
2. Export schema to new database
3. Change connection string in extracted module
4. Replace in-process API calls with HTTP/gRPC
5. Original application continues with remaining schemas

**Example**:
```
Before: Single DB with schemas [payment, products, shipping, inventory, users]
After:  Payment DB [payment] + Main DB [products, shipping, inventory, users]
```
