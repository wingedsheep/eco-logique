# ADR-008: Error Handling in REST Endpoints

**Status**: Accepted

**Date**: 2024-11-04

---

## Decision

We implement a structured error handling strategy using a Global Exception Handler for cross-cutting concerns and Controller-based mapping for domain-specific errors. We adopt the **Zalando Problem** format for all error responses.

---

## Context

*   The application has use cases in the service layer.
*   Domain errors should be handled explicitly.
*   The Domain layer should be agnostic of HTTP and DTOs.
*   Controllers act as the boundary, mapping domain results to HTTP responses.

---

## Strategy

### 1. Global Exception Handler
The Global Exception Handler is responsible for unexpected errors and framework-level issues. It does **not** handle business logic errors.

*   **Handles**:
    *   `UnexpectedException` (500 Internal Server Error)
    *   `AuthenticationException` / `AuthorizationException` (401/403)
    *   Argument Mapping errors (400 Bad Request, e.g., JSON parse errors, validation failures)
*   **Response**: Returns a standardized Problem JSON.

### 2. Domain Errors
Domain errors are treated as data, not exceptions.

*   **Sealed Classes**: Service layer methods return `Result<T, E>` (or a similar Result type) where `E` is a sealed class hierarchy of specific domain errors.
*   **Exhaustiveness**: This forces the consumer (the Controller) to handle all possible error cases.
*   **Isolation**: The Domain layer knows nothing about HTTP status codes or DTOs.

### 3. Controller Responsibility
The Controller acts as the translation layer between the Domain and HTTP.

*   **Calls** the service/use case.
*   **Matches** on the `Result`.
*   **On Success**: Returns `ResponseEntity` with the DTO.
*   **On Failure (Domain Error)**: Maps the specific domain error to the appropriate HTTP status and Problem detail.

### 4. Error Response Structure (Zalando Problem)
All error responses must follow the [RFC 7807](https://tools.ietf.org/html/rfc7807) standard (Problem Details for HTTP APIs).

*   `type`: URI reference that identifies the problem type.
*   `title`: Short, human-readable summary of the problem type.
*   `status`: The HTTP status code.
*   `detail`: Human-readable explanation specific to this occurrence of the problem.
*   `instance`: URI reference that identifies the specific occurrence of the problem.

#### Example

**Domain Layer**:
```kotlin
sealed class CreateOrderError {
    data object OutOfStock : CreateOrderError()
    data class InvalidAddress(val reason: String) : CreateOrderError()
}

interface OrderService {
    fun createOrder(order: Order): Result<Order, CreateOrderError>
}
```

**Controller Layer**:
```kotlin
@PostMapping
fun createOrder(@RequestBody request: CreateOrderRequest): ResponseEntity<Any> {
    return orderService.createOrder(request.toDomain())
        .fold(
            onSuccess = { order -> ResponseEntity.ok(order.toDto()) },
            onFailure = { error ->
                when (error) {
                    is CreateOrderError.OutOfStock -> Problem.builder()
                        .withType(URI.create("https://economique.com/errors/out-of-stock"))
                        .withTitle("Out of Stock")
                        .withStatus(Status.CONFLICT)
                        .withDetail("The requested product is out of stock.")
                        .build()
                    is CreateOrderError.InvalidAddress -> Problem.builder()
                         .withType(URI.create("https://economique.com/errors/invalid-address"))
                         .withTitle("Invalid Address")
                         .withStatus(Status.BAD_REQUEST)
                         .withDetail(error.reason)
                         .build()
                }.toResponseEntity()
            }
        )
}
```

---

## Consequences

### Positive
*   **Type-safety**: The compiler enforces handling of all known domain errors.
*   **Separation of Concerns**: The domain layer remains pure, while the controller handles HTTP specifics.
*   **Standardization**: Clients receive consistent error responses (Problem JSON).
*   **Predictability**: No "magic" exception throwing for control flow in business logic.

### Negative
*   **Boilerplate**: Controllers must explicitly map every domain error, leading to more code compared to global exception handling.
*   **Hierarchy Maintenance**: Developers must define and maintain error class hierarchies.
