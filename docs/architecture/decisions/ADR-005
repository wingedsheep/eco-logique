# ADR-005: Communication Between Modules

**Status**: Accepted

**Date**: 2024-11-02

---

## Decision

Modules communicate through **synchronous service calls** for immediate consistency, and **domain events** for asynchronous, decoupled communication.

---

## Synchronous (Direct Service Calls)

**When:** Immediate consistency required, need return value, part of core flow

```kotlin
@Service
class ShipmentService(
    private val productService: ProductService  // Injected from products module
) {
    fun createShipment(productId: ProductId): Result<Shipment> {
        val product = productService.findProduct(productId)
            ?: return Result.failure(ProductNotFoundException(productId))

        return Result.success(Shipment(productId, product.weight))
    }
}
```

---

## Asynchronous (Domain Events)

**When:** Eventual consistency acceptable, loose coupling desired, side effects

```kotlin
// Define event
data class PaymentCompleted(
    val paymentId: PaymentId,
    val orderId: OrderId,
    val timestamp: Instant
)

// Publish
@Service
class PaymentService(
    private val eventPublisher: ApplicationEventPublisher
) {
    fun completePayment(paymentId: PaymentId): Result<Payment> {
        // ... payment logic ...
        eventPublisher.publishEvent(PaymentCompleted(paymentId, orderId, Instant.now()))
        return Result.success(payment)
    }
}

// Listen
@Component
class PaymentCompletedListener(
    private val shipmentService: ShipmentService
) {
    @EventListener
    fun onPaymentCompleted(event: PaymentCompleted) {
        shipmentService.startFulfillment(event.orderId)
    }
}
```

---

## Testing

```kotlin
// Test publishing
@Test
fun `should publish event`() {
    paymentService.completePayment(paymentId)
    verify(eventPublisher).publishEvent(any<PaymentCompleted>())
}

// Test listening
@Test
fun `should handle event`() {
    listener.onPaymentCompleted(event)
    verify(shipmentService).startFulfillment(event.orderId)
}
```

---

## Consequences

**Positive:** Clear patterns, simple direct calls, loose coupling via events, can migrate to message queue later

**Negative:** Async flow harder to debug, need idempotency handling
