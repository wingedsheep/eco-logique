# ADR-001: Use Modular Monolith Architecture

**Status**: Accepted

**Date**: 2024-11-02

---

## Decision

We implement a **modular monolith** with strict module boundaries and clear communication patterns.

---

## Module Structure

Each domain is a Gradle module with three submodules:

```
domain-name/
├── domain-name-api/        # Interfaces, domain models, events
├── domain-name-impl/       # Service, REST, persistence
└── domain-name-worldview/  # Test data
```

---

## Dependency Rules

1. **Modules depend only on other modules' `-api`, never `-impl`**
2. **No circular dependencies** - enforced by Gradle build
3. **Explicit dependencies in `build.gradle.kts`**

```kotlin
// shipping-impl/build.gradle.kts
dependencies {
    api(project(":domain:shipping:shipping-api"))
    implementation(project(":domain:products:products-api"))
    implementation(project(":domain:inventory:inventory-api"))
}
```

**Module dependency matrix**:
```
                 Payment  Products  Shipping  Inventory  Users
Payment            -        ✗         ✗         ✗         ✗
Products           ✗        -         ✗         ✗         ✗
Shipping           ✗        ✓         -         ✓         ✗
Inventory          ✗        ✓         ✗         -         ✗
Users              ✗        ✗         ✗         ✗         -
```

---

## Data Isolation

1. **Separate PostgreSQL schemas** per module: `payment`, `products`, `shipping`, `inventory`, `users`
2. **No shared tables** between modules
3. **No foreign keys** across schemas
4. **Cross-module data access** only through service APIs

```sql
CREATE SCHEMA payment;
CREATE SCHEMA products;
-- etc.
```

---

## Communication

### Synchronous (Direct Calls)
Use for immediate consistency.

```kotlin
@Service
class ShippingServiceImpl(
    private val productService: ProductService  // From products-api
) : ShippingService {
    override fun createShipment(productId: ProductId): Result<Shipment> {
        val product = productService.getProduct(productId).getOrElse {
            return Result.failure(it)
        }
        // Use product details
    }
}
```

### Asynchronous (Events)
Use for eventual consistency and loose coupling.

```kotlin
// Publish (payment-impl)
eventPublisher.publishEvent(PaymentCompleted(paymentId, orderId))

// Listen (shipping-impl)
@EventListener
fun onPaymentCompleted(event: PaymentCompleted) {
    shipmentService.startFulfillment(event.orderId)
}
```

---

## Implementation Patterns

### API Module
- Interfaces only, no implementations
- Domain models with validation
- Events
- No Spring annotations

### Implementation Module
- Service implementations
- REST controllers in `rest/v1/` or `rest/internal/`
- Persistence layer with entities marked `internal`
- Entity mappers in persistence package

### Repository Pattern
```kotlin
// Interface returns domain types
interface ProductRepository {
    fun findById(id: ProductId): Product?
    fun save(product: Product): Product
}

// Implementation uses internal entities
@Component
internal class ProductRepositoryImpl(
    private val jdbc: ProductRepositoryJdbc
) : ProductRepository {
    override fun findById(id: ProductId): Product? {
        return jdbc.findById(id.value).map { it.toProduct() }.orElse(null)
    }
}

// Spring Data JDBC is internal
@Repository
internal interface ProductRepositoryJdbc : CrudRepository<ProductEntity, String>
```

---

## Deployment

Single Spring Boot application:

```kotlin
// application/build.gradle.kts
dependencies {
    implementation(project(":domain:payment:payment-impl"))
    implementation(project(":domain:products:products-impl"))
    implementation(project(":domain:shipping:shipping-impl"))
    implementation(project(":domain:inventory:inventory-impl"))
    implementation(project(":domain:users:users-impl"))
}
```

- One deployable artifact
- Single database with multiple schemas
- All modules scale together

---

## Consequences

### Positive
- Simple deployment and operations
- Clear module boundaries enforced by build
- In-process communication (fast)
- Team autonomy within modules
- Can extract to microservices later if needed

### Negative
- All modules scale together
- Shared database
- All modules deployed together
- Requires discipline to respect boundaries
