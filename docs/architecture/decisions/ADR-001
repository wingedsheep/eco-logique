# ADR-001: Use Modular Monolith Architecture

**Status**: Accepted

**Date**: 2024-11-02

---

## Decision

We implement a **modular monolith** with strict module boundaries and clear communication patterns.

---

## Module Structure

Each module splits its codebase into public contract and internal implementation:

```
payment/
├── api/                    # Public contract (exposed to other modules)
│   ├── PaymentService.kt
│   ├── PaymentCompleted.kt
│   └── PaymentRequest.kt
├── service/                # Internal implementation
├── rest/
└── persistence/
```

---

## Public API Pattern

The public API package encapsulates interfaces, DTOs, and events that other modules can access, while keeping implementation details private.

**Public (in `api/` package)**:
```kotlin
// payment/api/PaymentService.kt
interface PaymentService {
    fun processPayment(request: PaymentRequest): Result<Payment>
}

// payment/api/PaymentCompleted.kt
data class PaymentCompleted(
    val paymentId: PaymentId,
    val timestamp: Instant
)
```

**Internal (outside `api/` package)**:
```kotlin
// payment/service/PaymentServiceImpl.kt
@Service
internal class PaymentServiceImpl(...) : PaymentService {
    // Hidden from other modules
}

// payment/persistence/PaymentEntity.kt
@Table("payments")
internal data class PaymentEntity(...)
```

Other modules depend on interfaces at compile-time, and dependency injection provides implementations at runtime.

---

## Dependency Rules

1. **Modules depend only on other modules' `api/` packages**
2. **No circular dependencies** - enforced by Gradle
3. **Implementation stays internal**

```kotlin
// shipping/build.gradle.kts
dependencies {
    // Only depend on public API
    implementation(project(":deployables:economique:products"))
    implementation(project(":deployables:economique:inventory"))
}

// shipping can only access products/api/, not products/service/
```

---

## Data Isolation

1. **Separate PostgreSQL schemas** per module
2. **No shared tables** or foreign keys across schemas
3. **Cross-module data access** only through public APIs

---

## Communication

### Synchronous
Direct calls to service interfaces from `api/` package.

### Asynchronous
Message contracts (domain events) are the public API in asynchronous scenarios.

---

## Deployment

Single Spring Boot application with all module implementations:

```kotlin
// application/build.gradle.kts
dependencies {
    implementation(project(":deployables:economique:payment"))
    implementation(project(":deployables:economique:products"))
}
```

---

## Consequences

### Positive
- Clean contracts without implementation details exposed
- Implementation changes don't affect other modules
- Explicit, controlled coupling through public APIs
- Simple deployment and operations
- Easy to extract to microservices later

### Negative
- All modules scale together
- Shared database
- All modules deployed together
- Requires discipline to maintain contract stability
