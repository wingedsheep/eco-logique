# ADR-009: Hexagonal Module Architecture (Light)

**Status**: Accepted

**Date**: 2024-05-23

---

## Decision

To balance maintainability with simplicity, we adopt a **"Hex Light"** architecture for the internal structure of all domain modules (`-impl` modules).

This approach strictly separates concerns but avoids over-abstraction (e.g., redundant interfaces for every use case).

The code is organized into three distinct layers:
1.  **Domain**: Core business logic. Pure Kotlin. No Frameworks.
2.  **Application**: Orchestration. Depends on *Domain*.
3.  **Infrastructure**: Implementation details. Depends on *Application* and *Domain*.

---

## Package Structure

All classes within the `impl` module of a domain (e.g., `inventory`) must follow this package structure:

```
com.wingedsheep.ecologique.inventory.impl
├── domain                  # CORE: Pure business logic
│   ├── model               # Entities, Value Objects, Aggregates
│   └── service             # Domain Services (logic spanning multiple entities)
├── application             # ORCHESTRATION: Use Cases
│   └── service             # Application Services (Transaction boundaries)
└── infrastructure          # FRAMEWORK & IO: Everything else
    ├── web                 # REST Controllers, API DTOs, DTO Mappers
    └── persistence         # Spring Data JDBC Repositories, JDBC Entities, Entity Mappers
```

---

## Class Responsibilities & Rules

### 1. Domain Layer (`domain`)
*   **Responsibility**: Encapsulate enterprise business rules and state.
*   **Types**:
    *   **Aggregates/Entities**: Objects with ID and lifecycle.
    *   **Value Objects**: Immutable attributes.
    *   **Domain Services**: Pure logic involving multiple entities.
    *   **Repository Interfaces**: Definitions of how to access data (Output Ports).
*   **Rules**:
    *   **NO** Spring dependency.
    *   **NO** JPA/Persistence dependency.
    *   Pure Kotlin.

### 2. Application Layer (`application`)
*   **Responsibility**: Orchestrate domain objects to fulfill a specific user intent.
*   **Types**:
    *   **Application Services**: Classes annotated with `@Service`. Manage transactions (`@Transactional`).
    *   **DTOs**: Input/Output data structures (only if application-specific DTOs are needed).
*   **Rules**:
    *   Depends **ONLY** on `domain`.
    *   Coordinates the flow: Load Aggregate → Call Domain Method → Save Aggregate.
    *   Does **NOT** contain business rules.

### 3. Infrastructure Layer (`infrastructure`)
*   **Responsibility**: Adapt the outside world to the application and vice-versa.
*   **Types**:
    *   **Web**: `@RestController`, Request/Response DTOs.
    *   **Persistence**: Spring Data JDBC repositories, `@Table` entities.
    *   **Mappers**: Extension functions to convert between Domain Objects and DTOs/Entities.
        *   **Web Mappers**: Located in `infrastructure.web`.
        *   **Persistence Mappers**: Located in `infrastructure.persistence`.
*   **Rules**:
    *   Depends on `application` and `domain`.
    *   **NEVER** referenced by `domain` or `application`.
    *   Mappers should be **extension functions** (e.g., `fun InventoryItem.toDto()`), not Component classes.

---

## Complete Example: Inventory Module

This example demonstrates how the code is split between the `inventory-api` and `inventory-impl` modules.

### Module: `inventory-api`
Contains the Domain Model, Value Objects, Domain Events, and Output Port Interfaces (Repositories).

**`domain/model/InventoryItem.kt`**
```kotlin
data class InventoryItem(
    val sku: Sku,
    val quantity: Quantity
) {
    fun reduceStock(amount: Quantity): Result<InventoryItem, InventoryError> {
        if (quantity < amount) return Result.failure(InventoryError.InsufficientStock)
        return Result.success(copy(quantity = quantity - amount))
    }
}
```

**`domain/repository/InventoryRepository.kt`**
```kotlin
interface InventoryRepository {
    fun findBySku(sku: Sku): InventoryItem?
    fun save(item: InventoryItem)
}
```

### Module: `inventory-impl`
Contains the Application Services (Use Cases) and Infrastructure (Web, Persistence).

**`application/service/ReduceStockService.kt`**
```kotlin
@Service
class ReduceStockService(private val repository: InventoryRepository) {
    @Transactional
    fun execute(sku: Sku, amount: Quantity): Result<InventoryItem, InventoryError> {
        val item = repository.findBySku(sku) ?: return Result.failure(InventoryError.NotFound)

        return item.reduceStock(amount).onSuccess { updatedItem ->
            repository.save(updatedItem)
        }
    }
}
```

**`infrastructure/web/InventoryController.kt`**
```kotlin
@RestController
class InventoryController(private val service: ReduceStockService) {
    @PostMapping("/inventory/{sku}/reduce")
    fun reduce(@PathVariable sku: String, @RequestBody request: ReduceStockRequest): ResponseEntity<Any> {
        // Map Web DTO -> Domain VO (or Application DTO)
        return service.execute(Sku(sku), Quantity(request.amount))
            .fold(
                onSuccess = { item -> ResponseEntity.ok(item.toDto()) },
                onFailure = { error -> error.toProblem().toResponseEntity() }
            )
    }
}

// Web DTOs
data class ReduceStockRequest(val amount: Int)
data class InventoryItemDto(val sku: String, val quantity: Int)

// Web Mappers (Extension Functions)
private fun InventoryItem.toDto() = InventoryItemDto(
    sku = this.sku.value,
    quantity = this.quantity.value
)
```

**`infrastructure/persistence/PostgresInventoryRepository.kt`**
```kotlin
@Component
class PostgresInventoryRepository(
    private val jdbcRepository: SpringDataJdbcInventoryRepository
) : InventoryRepository {
    override fun findBySku(sku: Sku): InventoryItem? {
        return jdbcRepository.findBySku(sku.value)?.toDomain()
    }

    override fun save(item: InventoryItem) {
        jdbcRepository.save(item.toJdbcEntity())
    }
}

// JDBC Entity (Internal to Infrastructure)
@Table("inventory_items")
data class InventoryJdbcEntity(
    @Id val id: Long? = null,
    val sku: String,
    val quantity: Int
)

interface SpringDataJdbcInventoryRepository : ListCrudRepository<InventoryJdbcEntity, Long> {
    fun findBySku(sku: String): InventoryJdbcEntity?
}

// Persistence Mappers (Extension Functions)
private fun InventoryJdbcEntity.toDomain() = InventoryItem(
    sku = Sku(this.sku),
    quantity = Quantity(this.quantity)
)

private fun InventoryItem.toJdbcEntity(existingId: Long? = null) = InventoryJdbcEntity(
    id = existingId, // Id resolution logic would go here
    sku = this.sku.value,
    quantity = this.quantity.value
)
```
