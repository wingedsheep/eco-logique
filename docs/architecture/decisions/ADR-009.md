# ADR-009: Hexagonal Module Architecture

**Status**: Accepted

**Date**: 2024-05-23

---

## Decision

To ensure long-term maintainability, testability, and independence from frameworks, we adopt a **Hexagonal Architecture** (Ports and Adapters) for the internal structure of all domain modules (`-impl` modules).

The code is organized into three distinct layers with strict dependency rules:
1. **Domain**: The core business logic. Depends on *nothing*.
2. **Application**: Orchestration and use cases. Depends on *Domain*.
3. **Adapter**: Interaction with the outside world. Depends on *Application* and *Domain*.

---

## Package Structure

All classes within the `impl` module of a domain (e.g., `inventory`) must follow this package structure:

```
com.wingedsheep.ecologique.inventory.impl
├── domain                  # CORE: Pure business logic
│   ├── model               # Entities and Value Objects
│   └── service             # Domain Services (logic spanning multiple entities)
├── application             # ORCHESTRATION: Use Cases
│   ├── port                # Interfaces defining interactions
│   │   └── out             # Output Ports (Repository/Gateway interfaces)
│   └── service             # Application Services (Use Case implementations)
└── adapter                 # INFRASTRUCTURE: Implementation details
    ├── in                  # Driving Adapters (Input)
    │   └── web             # REST Controllers, API DTOs
    └── out                 # Driven Adapters (Output)
        └── persistence     # Database Repositories, JPA Entities, Mappers
```

---

## Class Responsibilities & Rules

### 1. Domain Layer (`domain`)
*   **Responsibility**: Encapsulate enterprise business rules.
*   **Types**:
    *   **Entities**: Objects with ID and lifecycle (e.g., `InventoryItem`).
    *   **Value Objects**: Immutable objects defined by attributes (e.g., `StockQuantity`).
    *   **Domain Services**: Logic that doesn't belong to a single entity.
*   **Rules**:
    *   Pure Kotlin code.
    *   **NO** framework annotations (No `@Entity`, `@Service`, `@JsonProperty`).
    *   **NO** dependencies on outer layers.

### 2. Application Layer (`application`)
*   **Responsibility**: Orchestrate domain objects to fulfill a use case. Handles transactions.
*   **Types**:
    *   **Application Services**: Classes implementing use cases (e.g., `UpdateStockService`). Returns `Result<T, E>`.
    *   **Output Ports**: Interfaces defining data access needs (e.g., `InventoryRepository`).
*   **Rules**:
    *   Annotated with `@Service` or `@UseCase`.
    *   Defines transaction boundaries (`@Transactional`).
    *   Orchestrates logic, does not implement core business rules.

### 3. Adapter Layer (`adapter`)
*   **Responsibility**: Adapt external inputs to the application and application outputs to external systems.
*   **Types**:
    *   **In / Web**:
        *   **Controllers**: Handle HTTP requests (`@RestController`).
        *   **DTOs**: Data contracts for API (Request/Response bodies).
        *   **Mappers**: Convert DTOs to/from Domain objects.
    *   **Out / Persistence**:
        *   **JPA Entities**: Database tables (`@Entity`, `@Table`).
        *   **Repository Impl**: Implementation of Output Ports using Spring Data/JPA.
        *   **Mappers**: Convert JPA Entities to/from Domain objects.

---

## Complete Example: Inventory Module

### `domain/model/InventoryItem.kt`
```kotlin
data class InventoryItem(
    val sku: Sku,
    val quantity: Quantity
) {
    fun reduceStock(amount: Quantity): Result<InventoryItem, InventoryError> {
        if (quantity < amount) return Result.failure(InventoryError.InsufficientStock)
        return Result.success(copy(quantity = quantity - amount))
    }
}
```

### `application/port/out/InventoryRepository.kt`
```kotlin
interface InventoryRepository {
    fun findBySku(sku: Sku): InventoryItem?
    fun save(item: InventoryItem)
}
```

### `application/service/ReduceStockService.kt`
```kotlin
@Service
class ReduceStockService(private val repository: InventoryRepository) {
    @Transactional
    fun execute(sku: Sku, amount: Quantity): Result<InventoryItem, InventoryError> {
        val item = repository.findBySku(sku) ?: return Result.failure(InventoryError.NotFound)

        return item.reduceStock(amount).onSuccess { updatedItem ->
            repository.save(updatedItem)
        }
    }
}
```

### `adapter/in/web/InventoryController.kt`
```kotlin
@RestController
class InventoryController(private val service: ReduceStockService) {
    @PostMapping("/inventory/{sku}/reduce")
    fun reduce(@PathVariable sku: String, @RequestBody request: ReduceStockRequest): ResponseEntity<Any> {
        return service.execute(Sku(sku), Quantity(request.amount))
            .fold(
                onSuccess = { item -> ResponseEntity.ok(item.toDto()) },
                onFailure = { error -> error.toProblem().toResponseEntity() }
            )
    }
}
```

### `adapter/out/persistence/PostgresInventoryRepository.kt`
```kotlin
@Component
class PostgresInventoryRepository(
    private val jpaRepository: JpaInventoryRepository
) : InventoryRepository {
    override fun findBySku(sku: Sku): InventoryItem? {
        return jpaRepository.findBySku(sku.value)?.toDomain()
    }

    override fun save(item: InventoryItem) {
        jpaRepository.save(item.toEntity())
    }
}
```
