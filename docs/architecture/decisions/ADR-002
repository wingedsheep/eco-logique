# ADR-002: Apply Domain-Driven Design

**Status**: Accepted

**Date**: 2024-11-02

---

## Decision

We apply **Domain-Driven Design** principles to organize code around business domains and maintain a shared understanding between developers and domain experts.

---

## Strategic Design

### Bounded Context

Each module represents one bounded context with its own domain model and ubiquitous language. Context boundaries = module boundaries.

```kotlin
// Products context - full product model
data class Product(
    val id: ProductId,
    val name: String,
    val price: Money,
    val sustainabilityRating: SustainabilityRating
)

// Shipping context - only cares about weight for shipping
class ShippingService(private val productService: ProductService) {
    fun calculateCost(productId: ProductId): Money {
        val product = productService.getProduct(productId)
        return calculateByWeight(product.weight)  // Only uses weight
    }
}
```

**Same real-world concept has different representations in different contexts.**

---

### Ubiquitous Language

Domain terms used consistently in code, conversations, and documentation. No translation needed.

```kotlin
// Products domain
enum class SustainabilityRating { A_PLUS, A, B, C, D }
data class CarbonFootprint(val kgCo2: BigDecimal)

// Payment domain
enum class PaymentStatus { PENDING, COMPLETED, FAILED }
data class Settlement(val amount: Money, val settledAt: Instant)

// Shipping domain
enum class ShipmentStatus { PENDING, IN_TRANSIT, DELIVERED }
data class TrackingNumber(val value: String)
```

Team members say "The product has an A+ sustainability rating" both in meetings and code.

---

### Context Map

Defines relationships between bounded contexts.

**Customer-Supplier**: Payment → Shipping
```kotlin
// Shipping depends on Payment events
@EventListener
fun onPaymentCompleted(event: PaymentCompleted) {
    shipmentService.startFulfillment(event.orderId)
}
```

**Shared Kernel**: All contexts share common value objects
```kotlin
// common modules
data class Money(val amount: BigDecimal, val currency: Currency)
enum class Country(val iso2: String)
```

**Anti-Corruption Layer**: External system integration
```kotlin
// Translate external PSP to our domain model
@Service
internal class PspAdapter(private val pspClient: PspClient) {
    fun processPayment(payment: Payment): Result<Payment> {
        val pspRequest = PspPaymentRequest(
            externalId = payment.id.value,
            amountInCents = (payment.amount.amount * 100).toInt()
        )
        val pspResponse = pspClient.createPayment(pspRequest)

        return Result.success(
            payment.copy(
                status = when (pspResponse.status) {
                    "SUCCESS" -> PaymentStatus.COMPLETED
                    "FAILURE" -> PaymentStatus.FAILED
                    else -> PaymentStatus.PENDING
                }
            )
        )
    }
}
```

---

## Tactical Design

### Entity

Object with identity that persists over time.

```kotlin
data class Product(
    val id: ProductId,  // Identity
    val name: String,
    val price: Money
) {
    fun withUpdatedPrice(newPrice: Money): Product {
        require(newPrice.amount > BigDecimal.ZERO)
        return copy(price = newPrice)
    }
}
```

Same product even if attributes change.

---

### Value Object

Immutable object defined by attributes, not identity.

```kotlin
data class Money(
    val amount: BigDecimal,
    val currency: Currency
) {
    init {
        require(amount >= BigDecimal.ZERO) { "Amount cannot be negative" }
    }

    operator fun plus(other: Money): Money {
        require(currency == other.currency)
        return Money(amount + other.amount, currency)
    }
}

data class Address(
    val street: String,
    val city: String,
    val postalCode: String,
    val country: Country
) {
    init {
        require(street.isNotBlank()) { "Street cannot be blank" }
    }
}

@JvmInline
value class ProductId(val value: String) {
    companion object {
        fun generate(): ProductId = ProductId("PROD-${UUID.randomUUID()}")
    }
}
```

---

### Aggregate

Cluster of entities/value objects with single root entity enforcing consistency.

```kotlin
data class Order(
    val id: OrderId,                    // Aggregate root
    val userId: UserId,
    val items: List<OrderItem>,         // Part of aggregate
    val totalPrice: Money,
    val status: OrderStatus
) {
    fun addItem(productId: ProductId, quantity: Int, price: Money): Order {
        require(status == OrderStatus.DRAFT) { "Cannot modify confirmed order" }
        val newItem = OrderItem(productId, quantity, price)
        return copy(
            items = items + newItem,
            totalPrice = calculateTotal(items + newItem)
        )
    }

    fun confirm(): Order {
        require(items.isNotEmpty()) { "Cannot confirm empty order" }
        return copy(status = OrderStatus.CONFIRMED)
    }
}

// OrderItem is NOT a separate entity - always accessed through Order
data class OrderItem(
    val productId: ProductId,
    val quantity: Int,
    val unitPrice: Money
)
```

**Consistency rules**: Can't add items to confirmed orders, can't confirm empty orders, total always matches items.

---

### Repository

Interface for storing/retrieving aggregate roots. Returns domain types, never entities.

```kotlin
interface ProductRepository {
    fun save(product: Product): Product
    fun findById(id: ProductId): Product?
    fun findByCategory(category: ProductCategory): List<Product>
}

@Component
internal class ProductRepositoryImpl(
    private val jdbc: ProductRepositoryJdbc
) : ProductRepository {
    override fun save(product: Product): Product {
        return jdbc.save(product.toProductEntity()).toProduct()
    }
}

@Repository
internal interface ProductRepositoryJdbc : CrudRepository<ProductEntity, String>
```

---

### Domain Service

Business logic that doesn't fit in entity or value object.

```kotlin
@Service
class ShippingCostCalculator(private val productService: ProductService) {
    fun calculateCost(productId: ProductId, destination: Country): Result<Money> {
        val product = productService.getProduct(productId).getOrThrow()

        val baseRate = when (product.weight.toKilograms()) {
            in BigDecimal.ZERO..BigDecimal.ONE -> Money(BigDecimal("3.50"), EUR)
            in BigDecimal.ONE..BigDecimal("5.0") -> Money(BigDecimal("6.50"), EUR)
            else -> Money(BigDecimal("12.00"), EUR)
        }

        val multiplier = if (destination == Country.NETHERLANDS)
            BigDecimal.ONE else BigDecimal("1.5")

        return Result.success(Money(baseRate.amount * multiplier, EUR))
    }
}
```

**Why domain service**: Cost depends on Product (weight) and Country (destination). Doesn't belong in either.

---

### Domain Event

Significant occurrence in the domain. Enables loose coupling.

```kotlin
// Event definitions
data class PaymentCompleted(
    val paymentId: PaymentId,
    val orderId: OrderId,
    val amount: Money,
    val timestamp: Instant
)

data class ProductCreated(
    val productId: ProductId,
    val timestamp: Instant
)

// Publishing
@Service
class ProductServiceImpl(
    private val productRepository: ProductRepository,
    private val eventPublisher: DomainEventPublisher
) : ProductService {
    override fun createProduct(...): Result<Product> = runCatching {
        val product = Product(...)
        val saved = productRepository.save(product)

        eventPublisher.publish(
            ProductCreated(saved.id, Instant.now())
        )
        saved
    }
}

// Consuming
@Component
class PaymentCompletedListener(private val shipmentService: ShipmentService) {
    @EventListener
    fun onPaymentCompleted(event: PaymentCompleted) {
        shipmentService.startFulfillment(event.orderId)
    }
}
```

**Event flow**: Payment completed → Inventory reserves stock → Shipment created → Email sent

---

## Domain Model Guidelines

### Location
Domain models in module root (not in `-api`), accessible to other modules:

```
products/
├── model/
│   ├── Product.kt
│   ├── ProductId.kt
│   └── Money.kt
├── service/
│   └── ProductService.kt
└── persistence/
```

### Technology-Agnostic
```kotlin
// ✓ Good - Pure domain model
data class Product(
    val id: ProductId,
    val name: String,
    val price: Money
) {
    init {
        require(name.isNotBlank()) { "Name cannot be blank" }
    }
}

// ✗ Bad - Infrastructure concerns leak in
@Entity  // JPA annotation
data class Product(
    @Id val id: String,  // Primitive instead of ProductId
    @Column(name = "product_name") val name: String
)
```

---

## Consequences

### Positive
- Code reflects business language
- Domain experts can validate code
- Clear boundaries between contexts
- Business logic isolated from technical concerns
- Easier onboarding through ubiquitous language

### Negative
- More upfront modeling effort
- Requires continuous collaboration with domain experts
- Can be overkill for simple CRUD operations
