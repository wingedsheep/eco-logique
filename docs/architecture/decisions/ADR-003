# ADR-003: Separate Database Schemas per Bounded Context

**Status**: Accepted

**Date**: 2024-11-02

---

## Decision

Each module owns its data exclusively through **separate PostgreSQL schemas**. No shared tables, no foreign keys across schemas.

---

## Schema Setup

```sql
-- docker/init/init-databases.sql
CREATE SCHEMA payment;
CREATE SCHEMA products;
CREATE SCHEMA shipping;
CREATE SCHEMA inventory;
CREATE SCHEMA users;

GRANT ALL ON SCHEMA payment TO economique_app;
-- etc.
```

---

## Migration Structure

```
application/src/main/resources/db/migration/
├── payment/
│   └── V1__create_payment_tables.sql
├── products/
│   └── V1__create_products_table.sql
└── shipping/
    └── V1__create_shipment_tables.sql
```

```yaml
# application.yml
spring:
  flyway:
    locations:
      - classpath:db/migration/payment
      - classpath:db/migration/products
      - classpath:db/migration/shipping
      - classpath:db/migration/inventory
      - classpath:db/migration/users
```

---

## Rules

**Always specify schema in migrations:**
```sql
CREATE TABLE products.products (
    id VARCHAR(255) PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    price_amount DECIMAL(19, 2) NOT NULL
);
```

**Never use foreign keys across schemas:**
```sql
-- ✗ Bad
CREATE TABLE inventory.items (
    product_id VARCHAR(255),
    FOREIGN KEY (product_id) REFERENCES products.products(id)
);

-- ✓ Good - String reference only
CREATE TABLE inventory.items (
    product_id VARCHAR(255) NOT NULL
);
```

**Access cross-schema data through service APIs:**
```kotlin
@Service
class InventoryServiceImpl(
    private val inventoryRepository: InventoryRepository,
    private val productService: ProductService  // From products module
) {
    override fun reserveStock(productId: ProductId): Result<Unit> {
        // Validate product exists via API, not database join
        productService.getProduct(productId).getOrElse {
            return Result.failure(it)
        }
        
        // Process reservation
    }
}
```

---

## Schema Ownership

- Only the owning module modifies its schema
- Other modules read through service APIs
- No cross-schema joins in application code
- No shared tables or "common" schema

---

## Consequences

### Positive
- Clear data ownership
- Modules evolve independently
- Easy to extract to separate databases later
- Forces proper API boundaries

### Negative
- Cannot use foreign keys for referential integrity across modules
- Cannot use database joins across modules
- More complex reporting queries
- Eventual consistency challenges

---

## Migration to Microservices

If extracting a module later:

```
Before: Single DB [payment, products, shipping, inventory, users]
After:  Payment DB [payment] + Main DB [products, shipping, inventory, users]
```

Change connection string, replace in-process calls with HTTP/gRPC. Schema already isolated.
